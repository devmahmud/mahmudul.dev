---
title: "JavaScript Equality, Explained Like a Human"
publishedAt: 2025-09-19
description: "When to use ===, when == helps, and the gotchas to remember."
slug: "js-equality-myths"
cover: "src/assets/posts/14/cover.jpg"
coverAlt: "Illustration for a JavaScript equality explainer"
ogImage: "/og-posts/14/cover.jpg"
tags: ["javascript", "equality", "coercion", "basics", "web"]
---

# Why equality in JS feels confusing

JavaScript has two equality operators that look similar but behave differently. Most confusion comes from not knowing when the language will convert types for you.


## ğŸ”‘ The Two Operators

* **`===` (Strict Equality)** â†’ compares **value + type**, no type conversion.
* **`==` (Loose Equality)** â†’ compares **value after type coercion**, which makes it *weird but sometimes useful*.

---

## ğŸš© Common Myths (and the truth)

### **Myth 1: `==` is always bad, never use it.**

âŒ Wrong.<br/>
âœ… Truth: `==` can be useful if you **intentionally want coercion**, e.g.

```js
0 == false   // true
"" == false  // true
null == undefined // true
```

It's dangerous when you *don't expect coercion*, but not always â€œbadâ€.

---

### **Myth 2: `===` is always safer.**

âŒ Not always.<br/>
âœ… Truth: `===` avoids surprises, but sometimes you **want coercion**:

```js
if (input == null) {
  // catches both null and undefined
}
```

Here, `==` is shorter and clearer than writing:

```js
if (input === null || input === undefined) { ... }
```

---

### **Myth 3: `null` and `undefined` are equal to everything with `==`.**

âŒ Nope.<br/>
âœ… Truth: they're only loosely equal to each other:

```js
null == undefined   // true
null == 0           // false
undefined == false  // false
```

---

### **Myth 4: `NaN == NaN` is true.**

âŒ Nope.<br/>
âœ… Truth: `NaN` is **never equal** to anything, not even itself:

```js
NaN == NaN   // false
NaN === NaN  // false
```

You must use:

```js
Number.isNaN(NaN)   // true
```

---

### **Myth 5: Objects are compared by value.**

âŒ Nope.<br/>
âœ… Truth: Objects are compared by **reference**, always:

```js
{} == {}    // false
[] == []    // false
```

Even if they look identical, different references â†’ not equal.

---

### **Myth 6: `[] == 0` is false.**

âŒ Weirdly, it's true.<br/>
âœ… Truth: because coercion happens:

```js
[] == 0
// [] â†’ "" â†’ 0
// so 0 == 0 â†’ true
```

---

### **Myth 7: `"0" == false` is false.**

âŒ Actually true.<br/>
âœ… Truth: `"0"` â†’ number `0`, and `false` â†’ number `0`, so:

```js
"0" == false   // true
```

---

## ğŸ§  Rule of Thumb

* Use **`===`** by default for safety.
* Use **`==`** *only when you know coercion rules* and want them (esp. for `null == undefined`).
* Always beware of weird corner cases like `[] == ![]`.
